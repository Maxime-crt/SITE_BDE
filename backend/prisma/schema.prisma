generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

generator erd {
  provider = "prisma-erd-generator"
  output   = "../erd.md"
  theme    = "forest"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  firstName        String
  lastName         String
  phone            String
  password         String
  isActive         Boolean  @default(true)
  isAdmin          Boolean  @default(false)
  isOnline         Boolean  @default(false)
  emailVerified    Boolean  @default(false)
  verificationCode String?
  codeExpiresAt    DateTime?
  lastLoginAt      DateTime?
  lastActivityAt   DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Uber Sharing Profile
  gender           String?  // MALE, FEMALE, OTHER, PREFER_NOT_SAY
  homeAddress      String?  // Adresse complète validée
  homeCity         String?  // Ville (pour filtre rapide)
  homePostcode     String?  // Code postal
  homeLatitude     Float?   // Coordonnées GPS pour calculs de distance
  homeLongitude    Float?   // Coordonnées GPS
  bdeCredit        Float    @default(0) // Crédit BDE pour remboursements Uber

  tickets          Ticket[]
  eventRatings     EventRating[]
  supportMessages  SupportMessage[]
  uberRideRequests UberRideRequest[]
  uberRideMessages UberRideMessage[]
  uberRidePayments UberRidePayment[]
  notifications    Notification[]

  @@map("users")
}

model Event {
  id          String   @id @default(cuid())
  name        String
  description String?
  location    String
  type        String   @default("CB") // CB, Mini CB, Afterwork, Autre
  customType  String?  // Pour le type "Autre"
  startDate   DateTime
  endDate     DateTime
  publishedAt DateTime? // Date de publication (null = brouillon)
  isActive    Boolean  @default(true)
  capacity    Int      @default(100) // Nombre total de places
  ticketPrice Float    @default(0) // Prix du billet (peut être 0 pour gratuit)
  rating      Float?
  ratingCount Int      @default(0)

  // Coordonnées GPS pour Uber Sharing
  latitude    Float?
  longitude   Float?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tickets          Ticket[]
  ratings          EventRating[]
  uberRides        UberRide[]
  uberRideRequests UberRideRequest[]

  @@map("events")
}

model Ticket {
  id              String   @id @default(cuid())
  eventId         String
  userId          String
  qrCode          String   @unique // Texte unique du QR code (ex: TICKET-xxx)
  qrCodeImage     String   @default("") // Image base64 du QR code
  status          String   @default("VALID") // VALID, USED, CANCELLED, REFUNDED
  purchasePrice   Float    // Prix payé (fixé au moment de l'achat)
  stripePaymentId String?  // ID du paiement Stripe
  purchasedAt     DateTime @default(now())
  usedAt          DateTime? // Quand le billet a été scanné

  event Event @relation(fields: [eventId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@map("tickets")
}

model EventRating {
  id        String   @id @default(cuid())
  eventId   String
  userId    String
  rating    Int      // Note de 1 à 5
  comment   String?
  createdAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@unique([eventId, userId])
  @@map("event_ratings")
}

model SupportMessage {
  id        String   @id @default(cuid())
  userId    String
  message   String
  isEdited  Boolean  @default(false)
  editCount Int      @default(0) // Nombre de modifications (max 2)
  replyToId String?
  isFromBDE Boolean  @default(false) // true si le message vient du BDE
  isRead    Boolean  @default(false) // true si le message a été lu par le destinataire
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User             @relation(fields: [userId], references: [id])
  replyTo SupportMessage?  @relation("MessageReply", fields: [replyToId], references: [id])
  replies SupportMessage[] @relation("MessageReply")

  @@map("support_messages")
}

// ========================================
// UBER SHARING MODELS
// ========================================

model UberRide {
  id                String   @id @default(cuid())
  eventId           String
  status            String   @default("MATCHING") // MATCHING, CONFIRMED, IN_PROGRESS, COMPLETED, CANCELLED
  departureTime     DateTime // Heure de départ planifiée
  departNow         Boolean  @default(false) // True si "partir maintenant" pendant l'event
  maxPassengers     Int      @default(4)
  currentPassengers Int      @default(0)

  // Adresse de départ (événement)
  departureAddress  String
  departureLat      Float
  departureLng      Float

  // Estimation et coût final
  estimatedCost     Float?   // Estimation via API (si disponible)
  finalCost         Float?   // Coût réel saisi par l'initiateur

  // Itinéraire optimisé (JSON array d'objets {userId, address, lat, lng, order})
  route             Json?
  routePolyline     String?  // Polyline encodée pour affichage carte

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  event    Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  requests UberRideRequest[]
  messages UberRideMessage[]
  payments UberRidePayment[]

  @@map("uber_rides")
}

model UberRideRequest {
  id                  String   @id @default(cuid())
  rideId              String
  userId              String
  eventId             String
  status              String   @default("PENDING") // PENDING, ACCEPTED, DECLINED, CANCELLED

  // Horaire souhaité
  maxDepartureTime    DateTime // Heure limite de départ souhaitée

  // Destination
  destinationAddress  String   // Adresse complète validée
  destinationCity     String
  destinationPostcode String
  destinationLat      Float
  destinationLng      Float

  // Préférences
  femaleOnly          Boolean  @default(false) // Uniquement femmes
  isInitiator         Boolean  @default(false) // Créateur du ride (celui qui appellera l'Uber)

  confirmedAt         DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  ride  UberRide @relation(fields: [rideId], references: [id], onDelete: Cascade)
  user  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([rideId, userId]) // Un user ne peut être qu'une fois dans un ride
  @@map("uber_ride_requests")
}

model UberRideMessage {
  id        String   @id @default(cuid())
  rideId    String
  userId    String
  message   String
  createdAt DateTime @default(now())

  ride UberRide @relation(fields: [rideId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id])

  @@map("uber_ride_messages")
}

model UberRidePayment {
  id                String   @id @default(cuid())
  rideId            String
  userId            String
  amount            Float    // Part à payer (calculée après la course)
  preAuthAmount     Float?   // Montant pré-autorisé
  status            String   @default("PENDING") // PENDING, PRE_AUTHORIZED, PAID, FAILED, REFUNDED
  stripePaymentId   String?  // Stripe Payment Intent ID
  paidAt            DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  ride UberRide @relation(fields: [rideId], references: [id], onDelete: Cascade)
  user User     @relation(fields: [userId], references: [id])

  @@unique([rideId, userId])
  @@map("uber_ride_payments")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // UBER_MATCH, UBER_CONFIRMED, UBER_CANCELLED, PAYMENT_REQUEST, PAYMENT_RECEIVED, etc.
  title     String
  message   String
  rideId    String?  // Lien vers un ride si applicable
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}


