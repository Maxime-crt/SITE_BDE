generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id               String   @id @default(cuid())
  email            String   @unique
  firstName        String
  lastName         String
  phone            String
  password         String
  isActive         Boolean  @default(true)
  isAdmin          Boolean  @default(false)
  isOnline         Boolean  @default(false)
  emailVerified    Boolean  @default(false)
  verificationCode String?
  codeExpiresAt    DateTime?
  lastLoginAt      DateTime?
  lastActivityAt   DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tickets        Ticket[]
  eventRatings   EventRating[]
  supportMessages SupportMessage[]

  @@map("users")
}

model Event {
  id          String   @id @default(cuid())
  name        String
  description String?
  location    String
  type        String   @default("CB") // CB, Mini CB, Afterwork, Autre
  customType  String?  // Pour le type "Autre"
  startDate   DateTime
  endDate     DateTime
  publishedAt DateTime? // Date de publication (null = brouillon)
  isActive    Boolean  @default(true)
  capacity    Int      @default(100) // Nombre total de places
  ticketPrice Float    @default(0) // Prix du billet (peut être 0 pour gratuit)
  rating      Float?
  ratingCount Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tickets Ticket[]
  ratings EventRating[]

  @@map("events")
}

model Ticket {
  id              String   @id @default(cuid())
  eventId         String
  userId          String
  qrCode          String   @unique // Texte unique du QR code (ex: TICKET-xxx)
  qrCodeImage     String   @default("") // Image base64 du QR code
  status          String   @default("VALID") // VALID, USED, CANCELLED, REFUNDED
  purchasePrice   Float    // Prix payé (fixé au moment de l'achat)
  stripePaymentId String?  // ID du paiement Stripe
  purchasedAt     DateTime @default(now())
  usedAt          DateTime? // Quand le billet a été scanné

  event Event @relation(fields: [eventId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@map("tickets")
}

model EventRating {
  id        String   @id @default(cuid())
  eventId   String
  userId    String
  rating    Int      // Note de 1 à 5
  comment   String?
  createdAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@unique([eventId, userId])
  @@map("event_ratings")
}

model SupportMessage {
  id        String   @id @default(cuid())
  userId    String
  message   String
  isEdited  Boolean  @default(false)
  editCount Int      @default(0) // Nombre de modifications (max 2)
  replyToId String?
  isFromBDE Boolean  @default(false) // true si le message vient du BDE
  isRead    Boolean  @default(false) // true si le message a été lu par le destinataire
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User             @relation(fields: [userId], references: [id])
  replyTo SupportMessage?  @relation("MessageReply", fields: [replyToId], references: [id])
  replies SupportMessage[] @relation("MessageReply")

  @@map("support_messages")
}


